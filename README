NAME
    Data::Format::Pretty::Console - Pretty-print data structure for console
    output

VERSION
    version 0.14

SYNOPSIS
    In your program:

     use Data::Format::Pretty::Console qw(format_pretty);
     ...
     print format_pretty($result);

    Some example output:

    Scalar, format_pretty("foo"):

     foo

    List, format_pretty([qw/foo bar baz qux/]):

     +------+
     | foo  |
     | bar  |
     | baz  |
     | qux  |
     '------'

    The same list, when program output is being piped (that is, (-t STDOUT)
    is false):

     foo
     bar
     baz
     qux

    Hash,
    format_pretty({foo=>"data",bar=>"format",baz=>"pretty",qux=>"console"}):

     +-----+---------+
     | bar | format  |
     | baz | pretty  |
     | foo | data    |
     | qux | console |
     '-----+---------'

    2-dimensional array, format_pretty([ [1, 2, ""], [28, "bar", 3], ["foo",
    3, undef] ]):

     +---------+---------+---------+
     |       1 |       2 |         |
     |      28 | bar     |       3 |
     | foo     |       3 |         |
     '---------+---------+---------'

    An array of hashrefs, such as commonly found if you use DBI's
    fetchrow_hashref() and friends, format_pretty([ {a=>1, b=>2}, {b=>2,
    c=>3}, {c=>4} ]):

     .-----------.
     | a | b | c |
     +---+---+---+
     | 1 | 2 |   |
     |   | 2 | 3 |
     |   |   | 4 |
     '---+---+---'

    Some more complex data, format_pretty({summary => "Blah...", users =>
    [{name=>"budi", domains=>["foo.com", "bar.com"], quota=>"1000"},
    {name=>"arif", domains=>["baz.com"], quota=>"2000"}], verified => 0}):

     summary:
     Blah...

     users:
     .---------------------------------.
     | domains          | name | quota |
     +------------------+------+-------+
     | foo.com, bar.com | budi |  1000 |
     | baz.com          | arif |  2000 |
     '------------------+------+-------'

     verified:
     0

    Structures which can't be handled yet will simply be output as YAML,
    format_pretty({a {b=>1}}):

     ---
     a:
       b: 1

DESCRIPTION
    This module is meant to output data structure in a "pretty" or "nice"
    format, suitable for console programs. The idea of this module is that
    for you to just merrily dump data structure to the console, and this
    module will figure out how to best display your data to the end-user.

    Currently this module tries to display the data mostly as a nice ASCII
    table (or a series of ASCII tables), and failing that, display it as
    YAML.

    This module takes piping into consideration, and will output a simpler,
    more suitable format when your user pipes your program's output into
    some other program.

    Most of the time, you don't have to configure anything, but some options
    are provided to tweak the output.

    This module uses Log::Any for logging.

FUNCTIONS
  format_pretty($data, \%opts)
    Return formatted data structure. Options:

    *   interactive => BOOL (optional, default undef)

        If set, will override interactive terminal detection (-t STDOUT).
        Simpler formatting will be done if terminal is non-interactive (e.g.
        when output is piped). Using this option will force simpler/full
        formatting.

    *   table_column_orders => [[COLNAME1, COLNAME2], ...]

        Specify column orders when drawing a table. If a table has all the
        columns, then the column names will be ordered according to the
        specification. For example, when table_column_orders is [[qw/foo bar
        baz/]], this table's columns will not be reordered because it
        doesn't have all the mentioned columns:

         |foo|quux|

        But this table will:

         |apple|bar|baz|foo|quux|

        into:

         |apple|foo|bar|baz|quux|

    *   table_column_formats => [{COLNAME=>FMT, ...}, ...]

        Specify formats for columns. Each table format specification is a
        hashref {COLNAME=>FMT, COLNAME2=>FMT2, ...}. It will be applied to a
        table if the table has all the columns. FMT is a format
        specification according to Data::Unixish::Apply, it's basically
        either a name of a dux function (e.g. 'date') or an array of
        function name + arguments (e.g. ['date', [align =>
        {align=>'middle'}]].

ENVIRONMENT
    *   FORMAT_PRETTY_TABLE_COLUMN_FORMATS

        To set table_column_formats, interpreted as JSON.

    *   FORMAT_PRETTY_TABLE_COLUMN_ORDERS

        To set table_column_orders, interpreted as JSON.

SEE ALSO
    Modules used for formatting: Text::ASCIITable, YAML.

    Data::Format::Pretty

AUTHOR
    Steven Haryanto <stevenharyanto@gmail.com>

COPYRIGHT AND LICENSE
    This software is copyright (c) 2012 by Steven Haryanto.

    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.

POD ERRORS
    Hey! The above document had some coding errors, which are explained
    below:

    Around line 573:
        '=item' outside of any '=over'

